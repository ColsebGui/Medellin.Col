; Stage 1 compiler with control flow support
; Streams ELF header, buffers code section for jump patching

parcero is_digit(c: numero) devuelve numero
    si c mayor_igual 48 y c menor_igual 57 entonces
        devuelvase 1
    listo
    devuelvase 0
fin parcero

parcero is_alpha(c: numero) devuelve numero
    si c mayor_igual 65 y c menor_igual 90 entonces
        devuelvase 1
    listo
    si c mayor_igual 97 y c menor_igual 122 entonces
        devuelvase 1
    listo
    si c es_igual 95 entonces
        devuelvase 1
    listo
    devuelvase 0
fin parcero

parcero is_alnum(c: numero) devuelve numero
    si is_alpha(c) es_igual 1 entonces
        devuelvase 1
    listo
    devuelvase is_digit(c)
fin parcero

parcero is_ws(c: numero) devuelve numero
    si c es_igual 32 o c es_igual 9 o c es_igual 10 o c es_igual 13 entonces
        devuelvase 1
    listo
    devuelvase 0
fin parcero

; Streaming emit for ELF header
parcero emit(b: numero) devuelve numero
    numero d
    d es escribir_byte(b)
    devuelvase 1
fin parcero

parcero emit_dword(v: numero) devuelve numero
    numero d
    numero t
    t es v
    d es emit(t menos ((t entre 256) por 256))
    t es t entre 256
    d es emit(t menos ((t entre 256) por 256))
    t es t entre 256
    d es emit(t menos ((t entre 256) por 256))
    t es t entre 256
    d es emit(t)
    devuelvase 4
fin parcero

parcero emit_qword(v: numero) devuelve numero
    numero d
    d es emit_dword(v)
    d es emit_dword(0)
    devuelvase 8
fin parcero

parcero emit_elf_header() devuelve numero
    numero d
    numero i
    d es emit(0x7F)
    d es emit(69)
    d es emit(76)
    d es emit(70)
    d es emit(2)
    d es emit(1)
    d es emit(1)
    d es emit(0)
    i es 0
    mientras i es_menor 8 haga
        d es emit(0)
        i es i mas 1
    listo
    d es emit(2)
    d es emit(0)
    d es emit(0x3E)
    d es emit(0)
    d es emit_dword(1)
    d es emit_qword(0x401000)
    d es emit_qword(64)
    d es emit_qword(0)
    d es emit_dword(0)
    d es emit(64)
    d es emit(0)
    d es emit(56)
    d es emit(0)
    d es emit(1)
    d es emit(0)
    d es emit(64)
    d es emit(0)
    d es emit(0)
    d es emit(0)
    d es emit(0)
    d es emit(0)
    d es emit_dword(1)
    d es emit_dword(5)
    d es emit_qword(0x1000)
    d es emit_qword(0x401000)
    d es emit_qword(0x401000)
    d es emit_qword(0x1000)
    d es emit_qword(0x1000)
    d es emit_qword(0x1000)
    i es 0
    mientras i es_menor 3976 haga
        d es emit(0)
        i es i mas 1
    listo
    devuelvase 0
fin parcero

parcero principal() devuelve numero
    arreglo[1024] de numero code
    arreglo[16] de numero buf
    arreglo[8] de numero vname
    arreglo[8] de numero voff
    numero pos
    numero c
    numero d
    numero len
    numero vcnt
    numero h
    numero val
    numero off
    numero i
    numero v
    numero op
    numero vh
    numero vh2
    numero voff2
    numero voff3
    numero vi
    numero vi2
    numero n2

    pos es 0
    vcnt es 0

    ; Stream ELF header
    d es emit_elf_header()

    ; Prologue to buffer
    code[pos] es 0x55
    pos es pos mas 1
    code[pos] es 0x48
    pos es pos mas 1
    code[pos] es 0x89
    pos es pos mas 1
    code[pos] es 0xE5
    pos es pos mas 1
    code[pos] es 0x48
    pos es pos mas 1
    code[pos] es 0x81
    pos es pos mas 1
    code[pos] es 0xEC
    pos es pos mas 1
    code[pos] es 0x00
    pos es pos mas 1
    code[pos] es 0x01
    pos es pos mas 1
    code[pos] es 0x00
    pos es pos mas 1
    code[pos] es 0x00
    pos es pos mas 1

    c es leer_byte()

    ; Skip to body - look for "devuelve"
    mientras c es_mayor 0 haga
        mientras is_ws(c) es_igual 1 y c es_mayor 0 haga
            c es leer_byte()
        listo
        si c es_igual 59 entonces
            mientras c es_mayor 0 y (no (c es_igual 10)) haga
                c es leer_byte()
            listo
            c es leer_byte()
        sino
            si is_alpha(c) es_igual 1 entonces
                len es 0
                mientras is_alnum(c) es_igual 1 y len es_menor 15 haga
                    buf[len] es c
                    len es len mas 1
                    c es leer_byte()
                listo
                si len es_igual 8 entonces
                    si buf[0] es_igual 100 y buf[1] es_igual 101 entonces
                        si buf[2] es_igual 118 y buf[3] es_igual 117 entonces
                            si buf[4] es_igual 101 y buf[5] es_igual 108 entonces
                                si buf[6] es_igual 118 y buf[7] es_igual 101 entonces
                                    mientras is_ws(c) es_igual 1 haga
                                        c es leer_byte()
                                    listo
                                    mientras is_alnum(c) es_igual 1 haga
                                        c es leer_byte()
                                    listo
                                    c es 0 menos 1
                                listo
                            listo
                        listo
                    listo
                listo
            sino
                c es leer_byte()
            listo
        listo
    listo

    c es leer_byte()

    ; Parse and emit to buffer
    mientras c es_mayor 0 haga
        mientras is_ws(c) es_igual 1 y c es_mayor 0 haga
            c es leer_byte()
        listo
        mientras c es_igual 59 haga
            mientras c es_mayor 0 y (no (c es_igual 10)) haga
                c es leer_byte()
            listo
            c es leer_byte()
            mientras is_ws(c) es_igual 1 y c es_mayor 0 haga
                c es leer_byte()
            listo
        listo

        si c menor_igual 0 entonces
            c es 0
        sino
            si is_alpha(c) es_igual 1 entonces
                len es 0
                mientras is_alnum(c) es_igual 1 y len es_menor 15 haga
                    buf[len] es c
                    len es len mas 1
                    c es leer_byte()
                listo

                ; fin
                si len es_igual 3 entonces
                    si buf[0] es_igual 102 y buf[1] es_igual 105 y buf[2] es_igual 110 entonces
                        c es 0
                    listo
                listo

                ; numero
                si len es_igual 6 y c es_mayor 0 entonces
                    si buf[0] es_igual 110 y buf[1] es_igual 117 entonces
                        si buf[2] es_igual 109 y buf[3] es_igual 101 entonces
                            si buf[4] es_igual 114 y buf[5] es_igual 111 entonces
                                mientras is_ws(c) es_igual 1 haga
                                    c es leer_byte()
                                listo
                                len es 0
                                mientras is_alnum(c) es_igual 1 y len es_menor 15 haga
                                    buf[len] es c
                                    len es len mas 1
                                    c es leer_byte()
                                listo
                                h es buf[0]
                                vname[vcnt] es h
                                vcnt es vcnt mas 1
                                voff[vcnt menos 1] es 0 menos (vcnt por 8)
                            listo
                        listo
                    listo
                listo

                ; devuelvase
                si len es_igual 10 y c es_mayor 0 entonces
                    si buf[0] es_igual 100 y buf[1] es_igual 101 entonces
                        si buf[2] es_igual 118 y buf[3] es_igual 117 entonces
                            si buf[4] es_igual 101 y buf[5] es_igual 108 entonces
                                si buf[6] es_igual 118 y buf[7] es_igual 97 entonces
                                    si buf[8] es_igual 115 y buf[9] es_igual 101 entonces
                                        mientras is_ws(c) es_igual 1 haga
                                            c es leer_byte()
                                        listo
                                        si is_digit(c) es_igual 1 entonces
                                            val es 0
                                            mientras is_digit(c) es_igual 1 haga
                                                val es val por 10 mas (c menos 48)
                                                c es leer_byte()
                                            listo
                                            ; mov rax, imm64
                                            code[pos] es 0x48
                                            pos es pos mas 1
                                            code[pos] es 0xB8
                                            pos es pos mas 1
                                            v es val
                                            code[pos] es v menos ((v entre 256) por 256)
                                            pos es pos mas 1
                                            v es v entre 256
                                            code[pos] es v menos ((v entre 256) por 256)
                                            pos es pos mas 1
                                            v es v entre 256
                                            code[pos] es v menos ((v entre 256) por 256)
                                            pos es pos mas 1
                                            v es v entre 256
                                            code[pos] es v
                                            pos es pos mas 1
                                            code[pos] es 0
                                            pos es pos mas 1
                                            code[pos] es 0
                                            pos es pos mas 1
                                            code[pos] es 0
                                            pos es pos mas 1
                                            code[pos] es 0
                                            pos es pos mas 1
                                        sino
                                            si is_alpha(c) es_igual 1 entonces
                                                len es 0
                                                mientras is_alnum(c) es_igual 1 y len es_menor 15 haga
                                                    buf[len] es c
                                                    len es len mas 1
                                                    c es leer_byte()
                                                listo
                                                h es buf[0]
                                                off es 0
                                                i es 0
                                                mientras i es_menor vcnt haga
                                                    si vname[i] es_igual h entonces
                                                        off es voff[i]
                                                    listo
                                                    i es i mas 1
                                                listo
                                                ; mov rax, [rbp+off]
                                                code[pos] es 0x48
                                                pos es pos mas 1
                                                code[pos] es 0x8B
                                                pos es pos mas 1
                                                code[pos] es 0x45
                                                pos es pos mas 1
                                                code[pos] es off mas 256
                                                pos es pos mas 1
                                            listo
                                        listo
                                    listo
                                listo
                            listo
                        listo
                    listo
                listo

                ; assignment: identifier "es" expression
                si c es_mayor 0 entonces
                    mientras is_ws(c) es_igual 1 haga
                        c es leer_byte()
                    listo
                    si c es_igual 101 entonces
                        n2 es leer_byte()
                        si n2 es_igual 115 entonces
                            c es leer_byte()
                            mientras is_ws(c) es_igual 1 haga
                                c es leer_byte()
                            listo
                            h es buf[0]
                            off es 0
                            i es 0
                            mientras i es_menor vcnt haga
                                si vname[i] es_igual h entonces
                                    off es voff[i]
                                listo
                                i es i mas 1
                            listo
                            ; Parse first operand
                            si is_digit(c) es_igual 1 entonces
                                val es 0
                                mientras is_digit(c) es_igual 1 haga
                                    val es val por 10 mas (c menos 48)
                                    c es leer_byte()
                                listo
                                ; mov rax, imm64
                                code[pos] es 0x48
                                pos es pos mas 1
                                code[pos] es 0xB8
                                pos es pos mas 1
                                v es val
                                code[pos] es v menos ((v entre 256) por 256)
                                pos es pos mas 1
                                v es v entre 256
                                code[pos] es v menos ((v entre 256) por 256)
                                pos es pos mas 1
                                v es v entre 256
                                code[pos] es v menos ((v entre 256) por 256)
                                pos es pos mas 1
                                v es v entre 256
                                code[pos] es v
                                pos es pos mas 1
                                code[pos] es 0
                                pos es pos mas 1
                                code[pos] es 0
                                pos es pos mas 1
                                code[pos] es 0
                                pos es pos mas 1
                                code[pos] es 0
                                pos es pos mas 1
                            sino
                                si is_alpha(c) es_igual 1 entonces
                                    len es 0
                                    mientras is_alnum(c) es_igual 1 y len es_menor 15 haga
                                        buf[len] es c
                                        len es len mas 1
                                        c es leer_byte()
                                    listo
                                    vh es buf[0]
                                    voff2 es 0
                                    vi es 0
                                    mientras vi es_menor vcnt haga
                                        si vname[vi] es_igual vh entonces
                                            voff2 es voff[vi]
                                        listo
                                        vi es vi mas 1
                                    listo
                                    ; mov rax, [rbp+off]
                                    code[pos] es 0x48
                                    pos es pos mas 1
                                    code[pos] es 0x8B
                                    pos es pos mas 1
                                    code[pos] es 0x45
                                    pos es pos mas 1
                                    code[pos] es voff2 mas 256
                                    pos es pos mas 1
                                listo
                            listo
                            ; Check for operator
                            mientras (c es_igual 32 o c es_igual 9) haga
                                c es leer_byte()
                            listo
                            si (c es_igual 109 o c es_igual 112 o c es_igual 101) entonces
                                op es 0
                                len es 0
                                mientras is_alnum(c) es_igual 1 y len es_menor 15 haga
                                    buf[len] es c
                                    len es len mas 1
                                    c es leer_byte()
                                listo
                                ; mas
                                si len es_igual 3 y buf[0] es_igual 109 y buf[1] es_igual 97 y buf[2] es_igual 115 entonces
                                    op es 1
                                listo
                                ; menos
                                si len es_igual 5 y buf[0] es_igual 109 y buf[1] es_igual 101 entonces
                                    si buf[2] es_igual 110 y buf[3] es_igual 111 y buf[4] es_igual 115 entonces
                                        op es 2
                                    listo
                                listo
                                ; por
                                si len es_igual 3 y buf[0] es_igual 112 y buf[1] es_igual 111 y buf[2] es_igual 114 entonces
                                    op es 3
                                listo
                                ; entre
                                si len es_igual 5 y buf[0] es_igual 101 y buf[1] es_igual 110 entonces
                                    si buf[2] es_igual 116 y buf[3] es_igual 114 y buf[4] es_igual 101 entonces
                                        op es 4
                                    listo
                                listo
                                si op es_mayor 0 entonces
                                    ; push rax
                                    code[pos] es 0x50
                                    pos es pos mas 1
                                    mientras is_ws(c) es_igual 1 haga
                                        c es leer_byte()
                                    listo
                                    ; Parse second operand
                                    si is_digit(c) es_igual 1 entonces
                                        val es 0
                                        mientras is_digit(c) es_igual 1 haga
                                            val es val por 10 mas (c menos 48)
                                            c es leer_byte()
                                        listo
                                        code[pos] es 0x48
                                        pos es pos mas 1
                                        code[pos] es 0xB8
                                        pos es pos mas 1
                                        v es val
                                        code[pos] es v menos ((v entre 256) por 256)
                                        pos es pos mas 1
                                        v es v entre 256
                                        code[pos] es v menos ((v entre 256) por 256)
                                        pos es pos mas 1
                                        v es v entre 256
                                        code[pos] es v menos ((v entre 256) por 256)
                                        pos es pos mas 1
                                        v es v entre 256
                                        code[pos] es v
                                        pos es pos mas 1
                                        code[pos] es 0
                                        pos es pos mas 1
                                        code[pos] es 0
                                        pos es pos mas 1
                                        code[pos] es 0
                                        pos es pos mas 1
                                        code[pos] es 0
                                        pos es pos mas 1
                                    sino
                                        si is_alpha(c) es_igual 1 entonces
                                            len es 0
                                            mientras is_alnum(c) es_igual 1 y len es_menor 15 haga
                                                buf[len] es c
                                                len es len mas 1
                                                c es leer_byte()
                                            listo
                                            vh2 es buf[0]
                                            voff3 es 0
                                            vi2 es 0
                                            mientras vi2 es_menor vcnt haga
                                                si vname[vi2] es_igual vh2 entonces
                                                    voff3 es voff[vi2]
                                                listo
                                                vi2 es vi2 mas 1
                                            listo
                                            code[pos] es 0x48
                                            pos es pos mas 1
                                            code[pos] es 0x8B
                                            pos es pos mas 1
                                            code[pos] es 0x45
                                            pos es pos mas 1
                                            code[pos] es voff3 mas 256
                                            pos es pos mas 1
                                        listo
                                    listo
                                    ; pop rbx
                                    code[pos] es 0x5B
                                    pos es pos mas 1
                                    ; xchg rax, rbx
                                    code[pos] es 0x48
                                    pos es pos mas 1
                                    code[pos] es 0x87
                                    pos es pos mas 1
                                    code[pos] es 0xD8
                                    pos es pos mas 1
                                    si op es_igual 1 entonces
                                        ; add rax, rbx
                                        code[pos] es 0x48
                                        pos es pos mas 1
                                        code[pos] es 0x01
                                        pos es pos mas 1
                                        code[pos] es 0xD8
                                        pos es pos mas 1
                                    listo
                                    si op es_igual 2 entonces
                                        ; sub rax, rbx
                                        code[pos] es 0x48
                                        pos es pos mas 1
                                        code[pos] es 0x29
                                        pos es pos mas 1
                                        code[pos] es 0xD8
                                        pos es pos mas 1
                                    listo
                                    si op es_igual 3 entonces
                                        ; imul rax, rbx
                                        code[pos] es 0x48
                                        pos es pos mas 1
                                        code[pos] es 0x0F
                                        pos es pos mas 1
                                        code[pos] es 0xAF
                                        pos es pos mas 1
                                        code[pos] es 0xC3
                                        pos es pos mas 1
                                    listo
                                    si op es_igual 4 entonces
                                        ; cqo + idiv rbx
                                        code[pos] es 0x48
                                        pos es pos mas 1
                                        code[pos] es 0x99
                                        pos es pos mas 1
                                        code[pos] es 0x48
                                        pos es pos mas 1
                                        code[pos] es 0xF7
                                        pos es pos mas 1
                                        code[pos] es 0xFB
                                        pos es pos mas 1
                                    listo
                                listo
                            listo
                            ; mov [rbp+off], rax
                            code[pos] es 0x48
                            pos es pos mas 1
                            code[pos] es 0x89
                            pos es pos mas 1
                            code[pos] es 0x45
                            pos es pos mas 1
                            code[pos] es off mas 256
                            pos es pos mas 1
                        sino
                            c es n2
                        listo
                    listo
                listo
            sino
                c es leer_byte()
            listo
        listo
    listo

    ; Epilogue
    code[pos] es 0x48
    pos es pos mas 1
    code[pos] es 0x89
    pos es pos mas 1
    code[pos] es 0xEC
    pos es pos mas 1
    code[pos] es 0x5D
    pos es pos mas 1
    code[pos] es 0x48
    pos es pos mas 1
    code[pos] es 0x89
    pos es pos mas 1
    code[pos] es 0xC7
    pos es pos mas 1
    code[pos] es 0xB8
    pos es pos mas 1
    code[pos] es 0x3C
    pos es pos mas 1
    code[pos] es 0x00
    pos es pos mas 1
    code[pos] es 0x00
    pos es pos mas 1
    code[pos] es 0x00
    pos es pos mas 1
    code[pos] es 0x0F
    pos es pos mas 1
    code[pos] es 0x05
    pos es pos mas 1

    ; Flush buffer
    i es 0
    mientras i es_menor pos haga
        d es escribir_byte(code[i])
        i es i mas 1
    listo

    devuelvase 0
fin parcero
