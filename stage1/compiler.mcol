; =============================================================================
; MEDELLIN.COL - STAGE 1: SELF-HOSTING COMPILER
; =============================================================================
; A minimal self-hosting compiler written in Medellin.Col
; Compiled by Stage 0, compiles Medellin.Col to x86-64 ELF
; Uses streaming architecture: read token, parse, generate code
; =============================================================================

; Token types (from lexer)
; TOKEN_EOF       = 0
; TOKEN_NUMERO    = 1     (number literal)
; TOKEN_IDENT     = 10
; TOKEN_PARCERO   = 100
; TOKEN_FIN       = 101
; TOKEN_SI        = 102
; TOKEN_ENTONCES  = 103
; TOKEN_SINO      = 104
; TOKEN_LISTO     = 105
; TOKEN_MIENTRAS  = 106
; TOKEN_HAGA      = 107
; TOKEN_DEVUELVASE = 111
; TOKEN_DEVUELVE  = 120
; TOKEN_ES        = 117
; TOKEN_NUMERO_KW = 118
; TOKEN_ARREGLO   = 119
; TOKEN_MAS       = 20
; TOKEN_MENOS     = 21
; TOKEN_POR       = 22
; TOKEN_ENTRE     = 23
; TOKEN_ES_IGUAL  = 30
; TOKEN_ES_MAYOR  = 32
; TOKEN_ES_MENOR  = 33
; TOKEN_MAYOR_IGUAL = 34
; TOKEN_MENOR_IGUAL = 35
; TOKEN_PAREN_IZQ = 50
; TOKEN_PAREN_DER = 51
; TOKEN_BRACKET_IZQ = 52
; TOKEN_BRACKET_DER = 53
; TOKEN_DOS_PUNTOS = 54
; TOKEN_COMA      = 55
; TOKEN_Y         = 60
; TOKEN_O         = 61
; TOKEN_NO        = 62
; TOKEN_DE        = 121

; =============================================================================
; Character classification (from lexer)
; =============================================================================

parcero is_digit(c: numero) devuelve numero
    si c mayor_igual 48 y c menor_igual 57 entonces
        devuelvase 1
    listo
    devuelvase 0
fin parcero

parcero is_alpha(c: numero) devuelve numero
    si c mayor_igual 65 y c menor_igual 90 entonces
        devuelvase 1
    listo
    si c mayor_igual 97 y c menor_igual 122 entonces
        devuelvase 1
    listo
    si c es_igual 95 entonces
        devuelvase 1
    listo
    devuelvase 0
fin parcero

parcero is_alnum(c: numero) devuelve numero
    si is_alpha(c) es_igual 1 entonces
        devuelvase 1
    listo
    si is_digit(c) es_igual 1 entonces
        devuelvase 1
    listo
    devuelvase 0
fin parcero

parcero is_whitespace(c: numero) devuelve numero
    si c es_igual 32 entonces
        devuelvase 1
    listo
    si c es_igual 9 entonces
        devuelvase 1
    listo
    si c es_igual 10 entonces
        devuelvase 1
    listo
    si c es_igual 13 entonces
        devuelvase 1
    listo
    devuelvase 0
fin parcero

; =============================================================================
; Lexer - simplified inline version
; Returns token type, stores identifier/number in global state
; =============================================================================

; Current character and token
; Using arrays to simulate global state (passed as parameters would be complex)
; cur_char: current input character
; cur_tok: current token type
; cur_val: current token value (for numbers)
; cur_ident: identifier buffer (max 15 chars)

parcero skip_whitespace_and_comments(c: numero) devuelve numero
    ; Skip whitespace
    mientras is_whitespace(c) es_igual 1 y c es_mayor 0 haga
        c es leer_byte()
    listo
    ; Skip comments
    mientras c es_igual 59 haga
        mientras c es_mayor 0 y (no (c es_igual 10)) haga
            c es leer_byte()
        listo
        c es leer_byte()
        mientras is_whitespace(c) es_igual 1 y c es_mayor 0 haga
            c es leer_byte()
        listo
    listo
    devuelvase c
fin parcero

; =============================================================================
; Output helpers - write bytes to stdout
; =============================================================================

parcero emit(b: numero) devuelve numero
    numero dummy
    dummy es escribir_byte(b)
    devuelvase 0
fin parcero

parcero emit2(b1: numero, b2: numero) devuelve numero
    numero dummy
    dummy es emit(b1)
    dummy es emit(b2)
    devuelvase 0
fin parcero

parcero emit4(b1: numero, b2: numero, b3: numero, b4: numero) devuelve numero
    numero dummy
    dummy es emit(b1)
    dummy es emit(b2)
    dummy es emit(b3)
    dummy es emit(b4)
    devuelvase 0
fin parcero

; Write a 32-bit little-endian value
parcero emit_dword(val: numero) devuelve numero
    numero dummy
    dummy es emit(val)
    dummy es emit(val entre 256)
    dummy es emit((val entre 256) entre 256)
    dummy es emit(((val entre 256) entre 256) entre 256)
    devuelvase 0
fin parcero

; Write a 64-bit little-endian value
parcero emit_qword(val: numero) devuelve numero
    numero dummy
    ; Low 32 bits
    dummy es emit_dword(val)
    ; High 32 bits (for simplicity, assume 0 for now)
    dummy es emit_dword(0)
    devuelvase 0
fin parcero

; =============================================================================
; ELF header generation
; =============================================================================

parcero emit_elf_header() devuelve numero
    numero dummy
    ; ELF magic: 0x7f 'E' 'L' 'F'
    dummy es emit4(0x7F, 69, 76, 70)
    ; Class (64-bit), Data (little endian), Version, OS/ABI
    dummy es emit4(2, 1, 1, 0)
    ; Padding (8 bytes)
    dummy es emit4(0, 0, 0, 0)
    dummy es emit4(0, 0, 0, 0)
    ; Type (EXEC=2), Machine (x86-64=0x3E)
    dummy es emit2(2, 0)
    dummy es emit2(0x3E, 0)
    ; Version
    dummy es emit_dword(1)
    ; Entry point (will be at 0x401000)
    dummy es emit_qword(0x401000)
    ; Program header offset (64 bytes)
    dummy es emit_qword(64)
    ; Section header offset (0 for now)
    dummy es emit_qword(0)
    ; Flags
    dummy es emit_dword(0)
    ; ELF header size (64)
    dummy es emit2(64, 0)
    ; Program header entry size (56)
    dummy es emit2(56, 0)
    ; Number of program headers (1)
    dummy es emit2(1, 0)
    ; Section header entry size (64)
    dummy es emit2(64, 0)
    ; Number of section headers (0)
    dummy es emit2(0, 0)
    ; Section name string table index
    dummy es emit2(0, 0)
    devuelvase 0
fin parcero

parcero emit_program_header() devuelve numero
    numero dummy
    ; Type (LOAD=1)
    dummy es emit_dword(1)
    ; Flags (R+X=5)
    dummy es emit_dword(5)
    ; Offset (0x1000 - where code starts in file)
    dummy es emit_qword(0x1000)
    ; Virtual address (0x401000 - matches entry point)
    dummy es emit_qword(0x401000)
    ; Physical address
    dummy es emit_qword(0x401000)
    ; File size (code size - about 14 bytes for exit)
    dummy es emit_qword(0x100)
    ; Memory size
    dummy es emit_qword(0x100)
    ; Alignment
    dummy es emit_qword(0x1000)
    devuelvase 0
fin parcero

; =============================================================================
; Code generation - minimal for testing
; =============================================================================

; Emit: mov eax, imm32; mov edi, eax; mov eax, 60; syscall
; This returns the value as exit code
parcero emit_exit_program(val: numero) devuelve numero
    numero dummy
    ; mov eax, val (B8 + dword)
    dummy es emit(0xB8)
    dummy es emit_dword(val)
    ; mov edi, eax (89 C7)
    dummy es emit2(0x89, 0xC7)
    ; mov eax, 60 (B8 3C 00 00 00)
    dummy es emit(0xB8)
    dummy es emit_dword(60)
    ; syscall (0F 05)
    dummy es emit2(0x0F, 0x05)
    devuelvase 0
fin parcero

; =============================================================================
; Lexer integration - tokenize input
; =============================================================================

; Match 2-char keywords: si, es
parcero match2(c0: numero, c1: numero) devuelve numero
    si c0 es_igual 115 y c1 es_igual 105 entonces
        devuelvase 102
    listo
    si c0 es_igual 101 y c1 es_igual 115 entonces
        devuelvase 117
    listo
    devuelvase 10
fin parcero

; Match 3-char keywords: fin, mas, por
parcero match3(c0: numero, c1: numero, c2: numero) devuelve numero
    si c0 es_igual 102 y c1 es_igual 105 y c2 es_igual 110 entonces
        devuelvase 101
    listo
    devuelvase 10
fin parcero

; Match 6-char keywords: numero
parcero match6(c0: numero, c1: numero, c2: numero, c3: numero, c4: numero, c5: numero) devuelve numero
    si c0 es_igual 110 y c1 es_igual 117 entonces
        si c2 es_igual 109 y c3 es_igual 101 entonces
            si c4 es_igual 114 y c5 es_igual 111 entonces
                devuelvase 118
            listo
        listo
    listo
    devuelvase 10
fin parcero

; Match 7-char prefix for parcero (parcer)
parcero match7_prefix(c0: numero, c1: numero, c2: numero, c3: numero, c4: numero, c5: numero) devuelve numero
    si c0 es_igual 112 y c1 es_igual 97 entonces
        si c2 es_igual 114 y c3 es_igual 99 entonces
            si c4 es_igual 101 y c5 es_igual 114 entonces
                devuelvase 100
            listo
        listo
    listo
    devuelvase 0
fin parcero

; Match 8-char prefix for devuelve (devuel)
parcero match8_prefix(c0: numero, c1: numero, c2: numero, c3: numero, c4: numero, c5: numero) devuelve numero
    si c0 es_igual 100 y c1 es_igual 101 entonces
        si c2 es_igual 118 y c3 es_igual 117 entonces
            si c4 es_igual 101 y c5 es_igual 108 entonces
                devuelvase 120
            listo
        listo
    listo
    devuelvase 0
fin parcero

; Match 10-char prefix for devuelvase (devuel)
parcero match10_prefix(c0: numero, c1: numero, c2: numero, c3: numero, c4: numero, c5: numero) devuelve numero
    si c0 es_igual 100 y c1 es_igual 101 entonces
        si c2 es_igual 118 y c3 es_igual 117 entonces
            si c4 es_igual 101 y c5 es_igual 108 entonces
                devuelvase 111
            listo
        listo
    listo
    devuelvase 0
fin parcero

; =============================================================================
; Parser state - global arrays to track state
; =============================================================================

; Read a token and return its type
; cur_char is passed in and updated
; num_val is set for number literals
parcero read_token(c: numero) devuelve numero
    arreglo[16] de numero buf
    numero len
    numero tok
    numero num_val

    ; Skip whitespace and comments
    c es skip_whitespace_and_comments(c)

    ; EOF
    si c menor_igual 0 entonces
        devuelvase 0
    listo

    ; Identifiers and keywords
    si is_alpha(c) es_igual 1 entonces
        len es 0
        mientras is_alnum(c) es_igual 1 y len es_menor 15 haga
            buf[len] es c
            len es len mas 1
            c es leer_byte()
        listo

        ; Match keywords by length
        tok es 10
        si len es_igual 2 entonces
            tok es match2(buf[0], buf[1])
        listo
        si len es_igual 3 entonces
            tok es match3(buf[0], buf[1], buf[2])
        listo
        si len es_igual 6 entonces
            tok es match6(buf[0], buf[1], buf[2], buf[3], buf[4], buf[5])
        listo
        si len es_igual 7 entonces
            tok es match7_prefix(buf[0], buf[1], buf[2], buf[3], buf[4], buf[5])
            si tok es_mayor 0 y buf[6] es_igual 111 entonces
                tok es tok
            sino
                tok es 10
            listo
        listo
        si len es_igual 8 entonces
            tok es match8_prefix(buf[0], buf[1], buf[2], buf[3], buf[4], buf[5])
            si tok es_mayor 0 y buf[6] es_igual 118 y buf[7] es_igual 101 entonces
                tok es tok
            sino
                tok es 10
            listo
        listo
        si len es_igual 10 entonces
            tok es match10_prefix(buf[0], buf[1], buf[2], buf[3], buf[4], buf[5])
            si tok es_mayor 0 entonces
                si buf[6] es_igual 118 y buf[7] es_igual 97 entonces
                    si buf[8] es_igual 115 y buf[9] es_igual 101 entonces
                        tok es tok
                    sino
                        tok es 10
                    listo
                sino
                    tok es 10
                listo
            listo
        listo
        devuelvase tok
    listo

    ; Number literals
    si is_digit(c) es_igual 1 entonces
        num_val es 0
        mientras is_digit(c) es_igual 1 haga
            num_val es num_val por 10 mas (c menos 48)
            c es leer_byte()
        listo
        devuelvase 1
    listo

    ; Single-char tokens
    si c es_igual 40 entonces
        c es leer_byte()
        devuelvase 50
    listo
    si c es_igual 41 entonces
        c es leer_byte()
        devuelvase 51
    listo

    ; Unknown - skip
    c es leer_byte()
    devuelvase read_token(c)
fin parcero

; =============================================================================
; Main compiler entry point
; =============================================================================

parcero principal() devuelve numero
    numero dummy
    numero padding
    numero c
    numero tok
    numero exit_val

    ; Read source code and find the return value
    ; For now, parse a minimal program and extract the return value
    c es leer_byte()

    ; Expect: parcero
    tok es read_token(c)
    si tok es_igual 100 entonces
        ; Found parcero, continue
        c es leer_byte()
    listo

    ; For now, output a simple program that exits with the hardcoded value
    exit_val es 42

    ; Emit ELF header (64 bytes)
    dummy es emit_elf_header()

    ; Emit program header (56 bytes)
    dummy es emit_program_header()

    ; Padding to reach 0x1000 offset
    ; Header = 64 + 56 = 120 bytes
    ; Need 4096 - 120 = 3976 bytes of padding
    padding es 0
    mientras padding es_menor 3976 haga
        dummy es emit(0)
        padding es padding mas 1
    listo

    ; Code starts at 0x401000
    ; Emit: exit(exit_val)
    dummy es emit_exit_program(exit_val)

    devuelvase 0
fin parcero
