; Stage 1 compiler with variables - streaming output approach
; Emits ELF header, then parses and emits code directly

parcero is_digit(c: numero) devuelve numero
    si c mayor_igual 48 y c menor_igual 57 entonces
        devuelvase 1
    listo
    devuelvase 0
fin parcero

parcero is_alpha(c: numero) devuelve numero
    si c mayor_igual 65 y c menor_igual 90 entonces
        devuelvase 1
    listo
    si c mayor_igual 97 y c menor_igual 122 entonces
        devuelvase 1
    listo
    si c es_igual 95 entonces
        devuelvase 1
    listo
    devuelvase 0
fin parcero

parcero is_alnum(c: numero) devuelve numero
    si is_alpha(c) es_igual 1 entonces
        devuelvase 1
    listo
    devuelvase is_digit(c)
fin parcero

parcero is_ws(c: numero) devuelve numero
    si c es_igual 32 o c es_igual 9 o c es_igual 10 o c es_igual 13 entonces
        devuelvase 1
    listo
    devuelvase 0
fin parcero

parcero emit(b: numero) devuelve numero
    numero d
    d es escribir_byte(b)
    devuelvase 0
fin parcero

parcero emit_dword(v: numero) devuelve numero
    numero d
    numero t
    t es v
    d es emit(t menos ((t entre 256) por 256))
    t es t entre 256
    d es emit(t menos ((t entre 256) por 256))
    t es t entre 256
    d es emit(t menos ((t entre 256) por 256))
    t es t entre 256
    d es emit(t)
    devuelvase 0
fin parcero

parcero emit_qword(v: numero) devuelve numero
    numero d
    d es emit_dword(v)
    d es emit_dword(0)
    devuelvase 0
fin parcero

parcero emit_elf_and_prologue() devuelve numero
    numero d
    numero i
    d es emit(0x7F)
    d es emit(69)
    d es emit(76)
    d es emit(70)
    d es emit(2)
    d es emit(1)
    d es emit(1)
    d es emit(0)
    i es 0
    mientras i es_menor 8 haga
        d es emit(0)
        i es i mas 1
    listo
    d es emit(2)
    d es emit(0)
    d es emit(0x3E)
    d es emit(0)
    d es emit_dword(1)
    d es emit_qword(0x401000)
    d es emit_qword(64)
    d es emit_qword(0)
    d es emit_dword(0)
    d es emit(64)
    d es emit(0)
    d es emit(56)
    d es emit(0)
    d es emit(1)
    d es emit(0)
    d es emit(64)
    d es emit(0)
    d es emit(0)
    d es emit(0)
    d es emit(0)
    d es emit(0)
    d es emit_dword(1)
    d es emit_dword(5)
    d es emit_qword(0x1000)
    d es emit_qword(0x401000)
    d es emit_qword(0x401000)
    d es emit_qword(0x1000)
    d es emit_qword(0x1000)
    d es emit_qword(0x1000)
    i es 0
    mientras i es_menor 3976 haga
        d es emit(0)
        i es i mas 1
    listo
    ; Prologue
    d es emit(0x55)
    d es emit(0x48)
    d es emit(0x89)
    d es emit(0xE5)
    d es emit(0x48)
    d es emit(0x81)
    d es emit(0xEC)
    d es emit(0x00)
    d es emit(0x01)
    d es emit(0x00)
    d es emit(0x00)
    devuelvase 0
fin parcero

parcero emit_epilogue() devuelve numero
    numero d
    d es emit(0x48)
    d es emit(0x89)
    d es emit(0xEC)
    d es emit(0x5D)
    d es emit(0x48)
    d es emit(0x89)
    d es emit(0xC7)
    d es emit(0xB8)
    d es emit(0x3C)
    d es emit(0x00)
    d es emit(0x00)
    d es emit(0x00)
    d es emit(0x0F)
    d es emit(0x05)
    devuelvase 0
fin parcero

parcero emit_mov_rax_imm(val: numero) devuelve numero
    numero d
    numero v
    d es emit(0x48)
    d es emit(0xB8)
    v es val
    d es emit(v menos ((v entre 256) por 256))
    v es v entre 256
    d es emit(v menos ((v entre 256) por 256))
    v es v entre 256
    d es emit(v menos ((v entre 256) por 256))
    v es v entre 256
    d es emit(v)
    d es emit(0)
    d es emit(0)
    d es emit(0)
    d es emit(0)
    devuelvase 0
fin parcero

parcero emit_mov_rax_rbp_off(off: numero) devuelve numero
    numero d
    d es emit(0x48)
    d es emit(0x8B)
    d es emit(0x45)
    d es emit(off mas 256)
    devuelvase 0
fin parcero

parcero emit_mov_rbp_off_rax(off: numero) devuelve numero
    numero d
    d es emit(0x48)
    d es emit(0x89)
    d es emit(0x45)
    d es emit(off mas 256)
    devuelvase 0
fin parcero

parcero emit_push_rax() devuelve numero
    numero d
    d es emit(0x50)
    devuelvase 0
fin parcero

parcero emit_pop_rbx() devuelve numero
    numero d
    d es emit(0x5B)
    devuelvase 0
fin parcero

; add rax, rbx (result in rax)
parcero emit_add_rax_rbx() devuelve numero
    numero d
    d es emit(0x48)
    d es emit(0x01)
    d es emit(0xD8)
    devuelvase 0
fin parcero

; sub rax, rbx (rax = rax - rbx)
parcero emit_sub_rax_rbx() devuelve numero
    numero d
    d es emit(0x48)
    d es emit(0x29)
    d es emit(0xD8)
    devuelvase 0
fin parcero

; imul rax, rbx (result in rax)
parcero emit_mul_rax_rbx() devuelve numero
    numero d
    d es emit(0x48)
    d es emit(0x0F)
    d es emit(0xAF)
    d es emit(0xC3)
    devuelvase 0
fin parcero

; idiv rbx (rax = rdx:rax / rbx, rdx = remainder)
; Need to sign-extend rax into rdx first with cqo
parcero emit_div_rax_rbx() devuelve numero
    numero d
    ; cqo - sign extend rax to rdx:rax
    d es emit(0x48)
    d es emit(0x99)
    ; idiv rbx
    d es emit(0x48)
    d es emit(0xF7)
    d es emit(0xFB)
    devuelvase 0
fin parcero

; cmp rax, rbx
parcero emit_cmp_rax_rbx() devuelve numero
    numero d
    d es emit(0x48)
    d es emit(0x39)
    d es emit(0xD8)
    devuelvase 0
fin parcero

; sete al (set if equal)
parcero emit_sete_al() devuelve numero
    numero d
    d es emit(0x0F)
    d es emit(0x94)
    d es emit(0xC0)
    devuelvase 0
fin parcero

; setne al (set if not equal)
parcero emit_setne_al() devuelve numero
    numero d
    d es emit(0x0F)
    d es emit(0x95)
    d es emit(0xC0)
    devuelvase 0
fin parcero

; setl al (set if less, signed)
parcero emit_setl_al() devuelve numero
    numero d
    d es emit(0x0F)
    d es emit(0x9C)
    d es emit(0xC0)
    devuelvase 0
fin parcero

; setg al (set if greater, signed)
parcero emit_setg_al() devuelve numero
    numero d
    d es emit(0x0F)
    d es emit(0x9F)
    d es emit(0xC0)
    devuelvase 0
fin parcero

; setle al (set if less or equal, signed)
parcero emit_setle_al() devuelve numero
    numero d
    d es emit(0x0F)
    d es emit(0x9E)
    d es emit(0xC0)
    devuelvase 0
fin parcero

; setge al (set if greater or equal, signed)
parcero emit_setge_al() devuelve numero
    numero d
    d es emit(0x0F)
    d es emit(0x9D)
    d es emit(0xC0)
    devuelvase 0
fin parcero

; movzx rax, al (zero extend al to rax)
parcero emit_movzx_rax_al() devuelve numero
    numero d
    d es emit(0x48)
    d es emit(0x0F)
    d es emit(0xB6)
    d es emit(0xC0)
    devuelvase 0
fin parcero

parcero principal() devuelve numero
    arreglo[16] de numero buf
    arreglo[8] de numero vname
    arreglo[8] de numero voff
    arreglo[4096] de numero code_buf
    numero code_pos
    numero c
    numero d
    numero len
    numero vcnt
    numero h
    numero val
    numero off
    numero i
    numero emit_mode

    vcnt es 0
    code_pos es 0
    emit_mode es 0
    d es emit_elf_and_prologue()
    c es leer_byte()

    ; Skip to body
    mientras c es_mayor 0 haga
        mientras is_ws(c) es_igual 1 y c es_mayor 0 haga
            c es leer_byte()
        listo
        si c es_igual 59 entonces
            mientras c es_mayor 0 y (no (c es_igual 10)) haga
                c es leer_byte()
            listo
            c es leer_byte()
        sino
            si is_alpha(c) es_igual 1 entonces
                len es 0
                mientras is_alnum(c) es_igual 1 y len es_menor 15 haga
                    buf[len] es c
                    len es len mas 1
                    c es leer_byte()
                listo
                si len es_igual 8 entonces
                    si buf[0] es_igual 100 y buf[1] es_igual 101 entonces
                        si buf[2] es_igual 118 y buf[3] es_igual 117 entonces
                            si buf[4] es_igual 101 y buf[5] es_igual 108 entonces
                                si buf[6] es_igual 118 y buf[7] es_igual 101 entonces
                                    mientras is_ws(c) es_igual 1 haga
                                        c es leer_byte()
                                    listo
                                    mientras is_alnum(c) es_igual 1 haga
                                        c es leer_byte()
                                    listo
                                    c es 0 menos 1
                                listo
                            listo
                        listo
                    listo
                listo
            sino
                c es leer_byte()
            listo
        listo
    listo

    c es leer_byte()

    ; Parse and emit
    mientras c es_mayor 0 haga
        mientras is_ws(c) es_igual 1 y c es_mayor 0 haga
            c es leer_byte()
        listo
        mientras c es_igual 59 haga
            mientras c es_mayor 0 y (no (c es_igual 10)) haga
                c es leer_byte()
            listo
            c es leer_byte()
            mientras is_ws(c) es_igual 1 y c es_mayor 0 haga
                c es leer_byte()
            listo
        listo

        si c menor_igual 0 entonces
            c es 0
        sino
            si is_alpha(c) es_igual 1 entonces
                len es 0
                mientras is_alnum(c) es_igual 1 y len es_menor 15 haga
                    buf[len] es c
                    len es len mas 1
                    c es leer_byte()
                listo

                ; fin
                si len es_igual 3 entonces
                    si buf[0] es_igual 102 y buf[1] es_igual 105 y buf[2] es_igual 110 entonces
                        c es 0
                    listo
                listo

                ; numero
                si len es_igual 6 y c es_mayor 0 entonces
                    si buf[0] es_igual 110 y buf[1] es_igual 117 entonces
                        si buf[2] es_igual 109 y buf[3] es_igual 101 entonces
                            si buf[4] es_igual 114 y buf[5] es_igual 111 entonces
                                mientras is_ws(c) es_igual 1 haga
                                    c es leer_byte()
                                listo
                                len es 0
                                mientras is_alnum(c) es_igual 1 y len es_menor 15 haga
                                    buf[len] es c
                                    len es len mas 1
                                    c es leer_byte()
                                listo
                                h es buf[0]
                                vname[vcnt] es h
                                vcnt es vcnt mas 1
                                voff[vcnt menos 1] es 0 menos (vcnt por 8)
                            listo
                        listo
                    listo
                listo

                ; devuelvase
                si len es_igual 10 y c es_mayor 0 entonces
                    si buf[0] es_igual 100 y buf[1] es_igual 101 entonces
                        si buf[2] es_igual 118 y buf[3] es_igual 117 entonces
                            si buf[4] es_igual 101 y buf[5] es_igual 108 entonces
                                si buf[6] es_igual 118 y buf[7] es_igual 97 entonces
                                    si buf[8] es_igual 115 y buf[9] es_igual 101 entonces
                                        mientras is_ws(c) es_igual 1 haga
                                            c es leer_byte()
                                        listo
                                        si is_digit(c) es_igual 1 entonces
                                            val es 0
                                            mientras is_digit(c) es_igual 1 haga
                                                val es val por 10 mas (c menos 48)
                                                c es leer_byte()
                                            listo
                                            d es emit_mov_rax_imm(val)
                                        sino
                                            si is_alpha(c) es_igual 1 entonces
                                                len es 0
                                                mientras is_alnum(c) es_igual 1 y len es_menor 15 haga
                                                    buf[len] es c
                                                    len es len mas 1
                                                    c es leer_byte()
                                                listo
                                                h es buf[0]
                                                off es 0
                                                i es 0
                                                mientras i es_menor vcnt haga
                                                    si vname[i] es_igual h entonces
                                                        off es voff[i]
                                                    listo
                                                    i es i mas 1
                                                listo
                                                d es emit_mov_rax_rbp_off(off)
                                            listo
                                        listo
                                    listo
                                listo
                            listo
                        listo
                    listo
                listo

                ; assignment
                si c es_mayor 0 entonces
                    mientras is_ws(c) es_igual 1 haga
                        c es leer_byte()
                    listo
                    si c es_igual 101 entonces
                        numero n2
                        n2 es leer_byte()
                        si n2 es_igual 115 entonces
                            c es leer_byte()
                            mientras is_ws(c) es_igual 1 haga
                                c es leer_byte()
                            listo
                            h es buf[0]
                            off es 0
                            i es 0
                            mientras i es_menor vcnt haga
                                si vname[i] es_igual h entonces
                                    off es voff[i]
                                listo
                                i es i mas 1
                            listo
                            ; Parse first operand (number or variable)
                            si is_digit(c) es_igual 1 entonces
                                val es 0
                                mientras is_digit(c) es_igual 1 haga
                                    val es val por 10 mas (c menos 48)
                                    c es leer_byte()
                                listo
                                d es emit_mov_rax_imm(val)
                            sino
                                si is_alpha(c) es_igual 1 entonces
                                    numero vh
                                    numero voff2
                                    numero vi
                                    len es 0
                                    mientras is_alnum(c) es_igual 1 y len es_menor 15 haga
                                        buf[len] es c
                                        len es len mas 1
                                        c es leer_byte()
                                    listo
                                    vh es buf[0]
                                    voff2 es 0
                                    vi es 0
                                    mientras vi es_menor vcnt haga
                                        si vname[vi] es_igual vh entonces
                                            voff2 es voff[vi]
                                        listo
                                        vi es vi mas 1
                                    listo
                                    d es emit_mov_rax_rbp_off(voff2)
                                listo
                            listo
                            ; Check for operator - only skip spaces, not newlines
                            mientras (c es_igual 32 o c es_igual 9) haga
                                c es leer_byte()
                            listo
                            ; Only parse operator if starts with m (mas,menos), p (por), e (entre)
                            si (c es_igual 109 o c es_igual 112 o c es_igual 101) entonces
                                numero op
                                op es 0
                                len es 0
                                mientras is_alnum(c) es_igual 1 y len es_menor 15 haga
                                    buf[len] es c
                                    len es len mas 1
                                    c es leer_byte()
                                listo
                                ; mas = 109,97,115
                                si len es_igual 3 y buf[0] es_igual 109 y buf[1] es_igual 97 y buf[2] es_igual 115 entonces
                                    op es 1
                                listo
                                ; menos = 109,101,110,111,115
                                si len es_igual 5 y buf[0] es_igual 109 y buf[1] es_igual 101 entonces
                                    si buf[2] es_igual 110 y buf[3] es_igual 111 y buf[4] es_igual 115 entonces
                                        op es 2
                                    listo
                                listo
                                ; por = 112,111,114
                                si len es_igual 3 y buf[0] es_igual 112 y buf[1] es_igual 111 y buf[2] es_igual 114 entonces
                                    op es 3
                                listo
                                ; entre = 101,110,116,114,101
                                si len es_igual 5 y buf[0] es_igual 101 y buf[1] es_igual 110 entonces
                                    si buf[2] es_igual 116 y buf[3] es_igual 114 y buf[4] es_igual 101 entonces
                                        op es 4
                                    listo
                                listo
                                ; es_igual = 101,115,95,105,103,117,97,108 (8 chars)
                                si len es_igual 8 y buf[0] es_igual 101 y buf[1] es_igual 115 entonces
                                    si buf[2] es_igual 95 y buf[3] es_igual 105 entonces
                                        si buf[4] es_igual 103 y buf[5] es_igual 117 entonces
                                            si buf[6] es_igual 97 y buf[7] es_igual 108 entonces
                                                op es 5
                                            listo
                                        listo
                                    listo
                                listo
                                ; es_menor = 101,115,95,109,101,110,111,114 (8 chars)
                                si len es_igual 8 y buf[0] es_igual 101 y buf[1] es_igual 115 entonces
                                    si buf[2] es_igual 95 y buf[3] es_igual 109 entonces
                                        si buf[4] es_igual 101 y buf[5] es_igual 110 entonces
                                            si buf[6] es_igual 111 y buf[7] es_igual 114 entonces
                                                op es 6
                                            listo
                                        listo
                                    listo
                                listo
                                ; es_mayor = 101,115,95,109,97,121,111,114 (8 chars)
                                si len es_igual 8 y buf[0] es_igual 101 y buf[1] es_igual 115 entonces
                                    si buf[2] es_igual 95 y buf[3] es_igual 109 entonces
                                        si buf[4] es_igual 97 y buf[5] es_igual 121 entonces
                                            si buf[6] es_igual 111 y buf[7] es_igual 114 entonces
                                                op es 7
                                            listo
                                        listo
                                    listo
                                listo
                                si op es_mayor 0 entonces
                                    d es emit_push_rax()
                                    mientras is_ws(c) es_igual 1 haga
                                        c es leer_byte()
                                    listo
                                    ; Parse second operand
                                    si is_digit(c) es_igual 1 entonces
                                        val es 0
                                        mientras is_digit(c) es_igual 1 haga
                                            val es val por 10 mas (c menos 48)
                                            c es leer_byte()
                                        listo
                                        d es emit_mov_rax_imm(val)
                                    sino
                                        si is_alpha(c) es_igual 1 entonces
                                            numero vh2
                                            numero voff3
                                            numero vi2
                                            len es 0
                                            mientras is_alnum(c) es_igual 1 y len es_menor 15 haga
                                                buf[len] es c
                                                len es len mas 1
                                                c es leer_byte()
                                            listo
                                            vh2 es buf[0]
                                            voff3 es 0
                                            vi2 es 0
                                            mientras vi2 es_menor vcnt haga
                                                si vname[vi2] es_igual vh2 entonces
                                                    voff3 es voff[vi2]
                                                listo
                                                vi2 es vi2 mas 1
                                            listo
                                            d es emit_mov_rax_rbp_off(voff3)
                                        listo
                                    listo
                                    ; Now rbx=left, rax=right, apply op
                                    d es emit_pop_rbx()
                                    ; Swap: we need left op right, but rbx=left, rax=right
                                    ; For add/mul order doesn't matter
                                    ; For sub/div we need rax=left, rbx=right
                                    ; So swap them: xchg rax,rbx = 48 87 D8
                                    d es emit(0x48)
                                    d es emit(0x87)
                                    d es emit(0xD8)
                                    si op es_igual 1 entonces
                                        d es emit_add_rax_rbx()
                                    listo
                                    si op es_igual 2 entonces
                                        d es emit_sub_rax_rbx()
                                    listo
                                    si op es_igual 3 entonces
                                        d es emit_mul_rax_rbx()
                                    listo
                                    si op es_igual 4 entonces
                                        d es emit_div_rax_rbx()
                                    listo
                                    ; Comparisons: cmp, setX, movzx
                                    si op es_igual 5 entonces
                                        d es emit_cmp_rax_rbx()
                                        d es emit_sete_al()
                                        d es emit_movzx_rax_al()
                                    listo
                                    si op es_igual 6 entonces
                                        d es emit_cmp_rax_rbx()
                                        d es emit_setl_al()
                                        d es emit_movzx_rax_al()
                                    listo
                                    si op es_igual 7 entonces
                                        d es emit_cmp_rax_rbx()
                                        d es emit_setg_al()
                                        d es emit_movzx_rax_al()
                                    listo
                                listo
                            listo
                            d es emit_mov_rbp_off_rax(off)
                        sino
                            c es n2
                        listo
                    listo
                listo
            sino
                c es leer_byte()
            listo
        listo
    listo

    d es emit_epilogue()
    devuelvase 0
fin parcero
