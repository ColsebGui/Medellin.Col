; =============================================================================
; MEDELLIN.COL - STAGE 1: SELF-HOSTING COMPILER
; =============================================================================
; A minimal self-hosting compiler written in Medellin.Col
; Compiled by Stage 0, compiles Medellin.Col to x86-64 ELF
; Uses streaming architecture: read token, parse, generate code
; =============================================================================

; Token types (from lexer)
; TOKEN_EOF       = 0
; TOKEN_NUMERO    = 1     (number literal)
; TOKEN_IDENT     = 10
; TOKEN_PARCERO   = 100
; TOKEN_FIN       = 101
; TOKEN_SI        = 102
; TOKEN_ENTONCES  = 103
; TOKEN_SINO      = 104
; TOKEN_LISTO     = 105
; TOKEN_MIENTRAS  = 106
; TOKEN_HAGA      = 107
; TOKEN_DEVUELVASE = 111
; TOKEN_DEVUELVE  = 120
; TOKEN_ES        = 117
; TOKEN_NUMERO_KW = 118
; TOKEN_ARREGLO   = 119
; TOKEN_MAS       = 20
; TOKEN_MENOS     = 21
; TOKEN_POR       = 22
; TOKEN_ENTRE     = 23
; TOKEN_ES_IGUAL  = 30
; TOKEN_ES_MAYOR  = 32
; TOKEN_ES_MENOR  = 33
; TOKEN_MAYOR_IGUAL = 34
; TOKEN_MENOR_IGUAL = 35
; TOKEN_PAREN_IZQ = 50
; TOKEN_PAREN_DER = 51
; TOKEN_BRACKET_IZQ = 52
; TOKEN_BRACKET_DER = 53
; TOKEN_DOS_PUNTOS = 54
; TOKEN_COMA      = 55
; TOKEN_Y         = 60
; TOKEN_O         = 61
; TOKEN_NO        = 62
; TOKEN_DE        = 121

; =============================================================================
; Character classification (from lexer)
; =============================================================================

parcero is_digit(c: numero) devuelve numero
    si c mayor_igual 48 y c menor_igual 57 entonces
        devuelvase 1
    listo
    devuelvase 0
fin parcero

parcero is_alpha(c: numero) devuelve numero
    si c mayor_igual 65 y c menor_igual 90 entonces
        devuelvase 1
    listo
    si c mayor_igual 97 y c menor_igual 122 entonces
        devuelvase 1
    listo
    si c es_igual 95 entonces
        devuelvase 1
    listo
    devuelvase 0
fin parcero

parcero is_alnum(c: numero) devuelve numero
    si is_alpha(c) es_igual 1 entonces
        devuelvase 1
    listo
    si is_digit(c) es_igual 1 entonces
        devuelvase 1
    listo
    devuelvase 0
fin parcero

parcero is_whitespace(c: numero) devuelve numero
    si c es_igual 32 entonces
        devuelvase 1
    listo
    si c es_igual 9 entonces
        devuelvase 1
    listo
    si c es_igual 10 entonces
        devuelvase 1
    listo
    si c es_igual 13 entonces
        devuelvase 1
    listo
    devuelvase 0
fin parcero

; =============================================================================
; Lexer - simplified inline version
; Returns token type, stores identifier/number in global state
; =============================================================================

; Current character and token
; Using arrays to simulate global state (passed as parameters would be complex)
; cur_char: current input character
; cur_tok: current token type
; cur_val: current token value (for numbers)
; cur_ident: identifier buffer (max 15 chars)

parcero skip_whitespace_and_comments(c: numero) devuelve numero
    ; Skip whitespace
    mientras is_whitespace(c) es_igual 1 y c es_mayor 0 haga
        c es leer_byte()
    listo
    ; Skip comments
    mientras c es_igual 59 haga
        mientras c es_mayor 0 y (no (c es_igual 10)) haga
            c es leer_byte()
        listo
        c es leer_byte()
        mientras is_whitespace(c) es_igual 1 y c es_mayor 0 haga
            c es leer_byte()
        listo
    listo
    devuelvase c
fin parcero

; =============================================================================
; Output helpers - write bytes to stdout
; =============================================================================

parcero emit(b: numero) devuelve numero
    numero dummy
    dummy es escribir_byte(b)
    devuelvase 0
fin parcero

parcero emit2(b1: numero, b2: numero) devuelve numero
    numero dummy
    dummy es emit(b1)
    dummy es emit(b2)
    devuelvase 0
fin parcero

parcero emit4(b1: numero, b2: numero, b3: numero, b4: numero) devuelve numero
    numero dummy
    dummy es emit(b1)
    dummy es emit(b2)
    dummy es emit(b3)
    dummy es emit(b4)
    devuelvase 0
fin parcero

; Write a 32-bit little-endian value
parcero emit_dword(val: numero) devuelve numero
    numero dummy
    dummy es emit(val)
    dummy es emit(val entre 256)
    dummy es emit((val entre 256) entre 256)
    dummy es emit(((val entre 256) entre 256) entre 256)
    devuelvase 0
fin parcero

; Write a 64-bit little-endian value
parcero emit_qword(val: numero) devuelve numero
    numero dummy
    ; Low 32 bits
    dummy es emit_dword(val)
    ; High 32 bits (for simplicity, assume 0 for now)
    dummy es emit_dword(0)
    devuelvase 0
fin parcero

; =============================================================================
; ELF header generation
; =============================================================================

parcero emit_elf_header() devuelve numero
    numero dummy
    ; ELF magic: 0x7f 'E' 'L' 'F'
    dummy es emit4(0x7F, 69, 76, 70)
    ; Class (64-bit), Data (little endian), Version, OS/ABI
    dummy es emit4(2, 1, 1, 0)
    ; Padding (8 bytes)
    dummy es emit4(0, 0, 0, 0)
    dummy es emit4(0, 0, 0, 0)
    ; Type (EXEC=2), Machine (x86-64=0x3E)
    dummy es emit2(2, 0)
    dummy es emit2(0x3E, 0)
    ; Version
    dummy es emit_dword(1)
    ; Entry point (will be at 0x401000)
    dummy es emit_qword(0x401000)
    ; Program header offset (64 bytes)
    dummy es emit_qword(64)
    ; Section header offset (0 for now)
    dummy es emit_qword(0)
    ; Flags
    dummy es emit_dword(0)
    ; ELF header size (64)
    dummy es emit2(64, 0)
    ; Program header entry size (56)
    dummy es emit2(56, 0)
    ; Number of program headers (1)
    dummy es emit2(1, 0)
    ; Section header entry size (64)
    dummy es emit2(64, 0)
    ; Number of section headers (0)
    dummy es emit2(0, 0)
    ; Section name string table index
    dummy es emit2(0, 0)
    devuelvase 0
fin parcero

parcero emit_program_header() devuelve numero
    numero dummy
    ; Type (LOAD=1)
    dummy es emit_dword(1)
    ; Flags (R+X=5)
    dummy es emit_dword(5)
    ; Offset (0x1000 - where code starts in file)
    dummy es emit_qword(0x1000)
    ; Virtual address (0x401000 - matches entry point)
    dummy es emit_qword(0x401000)
    ; Physical address
    dummy es emit_qword(0x401000)
    ; File size (code size - about 14 bytes for exit)
    dummy es emit_qword(0x100)
    ; Memory size
    dummy es emit_qword(0x100)
    ; Alignment
    dummy es emit_qword(0x1000)
    devuelvase 0
fin parcero

; =============================================================================
; Code generation - minimal for testing
; =============================================================================

; Emit: mov eax, imm32; mov edi, eax; mov eax, 60; syscall
; This returns the value as exit code
parcero emit_exit_program(val: numero) devuelve numero
    numero dummy
    ; mov eax, val (B8 + dword)
    dummy es emit(0xB8)
    dummy es emit_dword(val)
    ; mov edi, eax (89 C7)
    dummy es emit2(0x89, 0xC7)
    ; mov eax, 60 (B8 3C 00 00 00)
    dummy es emit(0xB8)
    dummy es emit_dword(60)
    ; syscall (0F 05)
    dummy es emit2(0x0F, 0x05)
    devuelvase 0
fin parcero

; =============================================================================
; Main compiler entry point
; For now: output a simple program that exits with code 42
; =============================================================================

parcero principal() devuelve numero
    numero dummy
    numero padding
    numero code_start

    ; Emit ELF header (64 bytes)
    dummy es emit_elf_header()

    ; Emit program header (56 bytes)
    dummy es emit_program_header()

    ; Padding to reach 0x1000 offset
    ; Header = 64 + 56 = 120 bytes
    ; Need 4096 - 120 = 3976 bytes of padding
    padding es 0
    mientras padding es_menor 3976 haga
        dummy es emit(0)
        padding es padding mas 1
    listo

    ; Code starts at 0x401000
    ; Emit: exit(42)
    dummy es emit_exit_program(42)

    devuelvase 0
fin parcero
